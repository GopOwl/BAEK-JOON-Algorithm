# 문제 주소 
https://www.acmicpc.net/problem/1929

## 문제 접근 방법 
소수 문제와 거의 같았던 문제 근데 아직 익숙치 않아서 참고해서 풀긴 풀었지만 복습이 필요함 

- (다른풀이) -------------------------------------------------------------
* 4948번을 이 문제 푼것처럼 풀려다가 도저히 안풀려서 에라스토텔레스의 체를 이용해서 다시 풀어보았다.
* 솔직히 저번 문제 풀이는 이해가 안되는 부분이 있었는데 이번거는 이해가 확실히 가서 앞으로 유사한 문제가 나오면 이 풀이 법으로 풀어볼것 같음 
* ``` let isPrimeNum = Array(N+1).fill(true); ``` 는 N+1개 만큼 true로 채워준다는 의미  ex)N이 2라면 [ture,ture,ture] 이런식으로 채워준다는 의미 
+ ``` isPrimeNum[0] = isPrimeNum[1] = false; ``` 0과 1은 소수가 아니니 false 
``` 
for (let i=2; i<=Math.ceil(Math.sqrt(N)); i++) {
        if(isPrimeNum[i]) {
            let m = 2;
            while(i*m <= N) {
                isPrimeNum[i*m] = false;
                m++;
            }
        }
    }
```
* 2부터 시작해서 Math.sqrt(N)은 루트 씌어준다고 생각 N의 제곱근까지 반복하는데 여기서 에라스토텔레스의 체를 이용 2를 제외한 배수들을 다 false로 바꿔준다.
자세한 그거는 블로그 

* i의 배수를 구하기 위해 let m = 2 라는 수를 선언을 해서 i의 배수가 N보다 작다면 그 배수 번째에 위치한 배열의 요소를 false로 만들어주고 m은 1플러스 해준다 while문이 거짓일때까지 
* 반복문을 다 돌고 나서 밑에 새롭게 이제는 주어진 범위 안에서 소수를 구하기 위해 새로 반복문을 다시 만들어서 맨처음 배열을 만들었던 isPrimeNum의 요소가 true 라면 그 해당하는 요소번째 숫자를 새롭게 선언한 배열 result에다가 push해서 값을 넣어준다. 

* 어차피 위에 반복문에서 소수가 아닌것들은 false로 바꾸어 주었기 때문에 true인 것들은 소수일 수 밖에 없다 

### 새롭게 알게 된 점 
Math.sqrt() 